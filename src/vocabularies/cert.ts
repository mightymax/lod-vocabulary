// This file is generated by the build script. Do not edit it manually.
import { prefixer as $prefixer } from '../utilities.js';
const prefixer = $prefixer('http://www.w3.org/ns/auth/cert#');

/**
 * [cert](http://www.w3.org/ns/auth/cert#})
 */
const cert = {
  /**
    * **[Certificate](http://www.w3.org/ns/auth/cert#Certificate)** (class)
    * 
    * A certificate is a Document that is signed.
    * As explained here http://www.pgpi.org/doc/pgpintro/#p16
    * 'A digital certificate consists of three things:
    * * A public key.
    * * Certificate information. ('Identity' information about the
    * user, such as name, user ID, and so on.)
    * * One or more digital signatures.'
    * 
    */
    Certificate: prefixer('Certificate'),

    /**
    * **[PGPCertificate](http://www.w3.org/ns/auth/cert#PGPCertificate)** (class)
    * 
    * the class of PGP Certificates
    */
    PGPCertificate: prefixer('PGPCertificate'),

    /**
    * **[PrivateKey](http://www.w3.org/ns/auth/cert#PrivateKey)** (class)
    * 
    * Private Key
    */
    PrivateKey: prefixer('PrivateKey'),

    /**
    * **[PublicKey](http://www.w3.org/ns/auth/cert#PublicKey)** (class)
    * 
    * Public Key
    */
    PublicKey: prefixer('PublicKey'),

    /**
    * **[RSA Key](http://www.w3.org/ns/auth/cert#RSAKey)** (class)
    * 
    * 
    * The union of the public and private components of an RSAKey.
    * Usually those pieces are not kept together
    * 
    */
    RSAKey: prefixer('RSAKey'),

    /**
    * **[RSA Public Key](http://www.w3.org/ns/auth/cert#RSAPublicKey)** (class)
    * 
    * 
    * The RSA public key.  Padded message m are encrypted by applying the function
    * modulus(power(m,exponent),modulus)
    * 
    */
    RSAPublicKey: prefixer('RSAPublicKey'),

    /**
    * **[Signature](http://www.w3.org/ns/auth/cert#Signature)** (class)
    * 
    * the class of signtatures
    */
    Signature: prefixer('Signature'),

    /**
    * **[X509Certificate](http://www.w3.org/ns/auth/cert#X509Certificate)** (class)
    * 
    * the class of X509 Certificates
    */
    X509Certificate: prefixer('X509Certificate'),

    /**
    * **[exponent](http://www.w3.org/ns/auth/cert#exponent)** (property)
    * 
    * 
    * The exponent used to encrypt the message. Number chosen between
    * 1 and the totient(p*q). Often named 'e' .
    * 
    */
    exponent: prefixer('exponent'),

    /**
    * **[modulus](http://www.w3.org/ns/auth/cert#modulus)** (property)
    * 
    * 
    * <p>The modulus of an RSA public and private key.
    * Or the modulus of a DSA Key.
    * The modulus is encoded as a hex binary. The binary is the same as the one encoded in the
    * <a href="http://www.w3.org/TR/xmldsig-core/#sec-CryptoBinary">XML DSIG CryptoBinary</a>
    * </p>
    * <blockquote>
    * This specification defines the ds:CryptoBinary simple type for representing arbitrary-length integers (e.g. "bignums") in XML as octet strings. The integer value is first converted to a "big endian" bitstring. The bitstring is then padded with leading zero bits so that the total number of bits == 0 mod 8 (so that there are an integral number of octets). If the bitstring contains entire leading octets that are zero, these are removed (so the high-order octet is always non-zero).
    * </blockquote>
    * <p>The only difference is that the octet string is then encoded using either xsd:base64Binary or xsd:hexBinary. Currently for all usages of this relation, the xsd:hexBinary datatype should be used until the SPARQL working group specifies specifies in its <a href="http://www.w3.org/TR/sparql11-entailment/#DEntRegime">D-Entailment</a> that those two types are equivalent.</p>
    * <p>It would have been better had there been a hexInteger datatype that was standard and supported by all tools.</p>
    * 
    */
    modulus: prefixer('modulus'),

    /**
    * **[private](http://www.w3.org/ns/auth/cert#privateExponent)** (property)
    * 
    * 
    * The exponent used to decrypt the message
    * calculated as
    * public_exponent*private_exponent = 1 modulo totient(p*q)
    * The private exponent is often named 'd'
    * 
    */
    privateExponent: prefixer('privateExponent'),

    /**
    * **[identity](http://www.w3.org/ns/auth/cert#identity)** (property)
    * 
    * 
    * the identity of the public key. This is the entity that knows the private key and
    * so can decrypt messages encrypted with the public key, or encrypt messages that can
    * be decrypted with the public key.
    * 
    */
    identity: prefixer('identity'),

    /**
    * **[key](http://www.w3.org/ns/auth/cert#key)** (property)
    * 
    * relates an agent to a key - most often the public key.
    */
    key: prefixer('key'),

  
  };

export default cert

